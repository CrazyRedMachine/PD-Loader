#include "RedBoard.h"
#include "../../framework.h"
#include "RedBoardButton.h"
#include "RedBoardState.h"
#include <stdio.h>
#include <string>
#include <iostream>

#include <process.h>
#include <hidsdi.h>
#include <SetupAPI.h>

namespace TLAC::Input
{
	/* TODO: cleanup that jank straight from divaio.c and rewrite as OOP :D */
	static bool diva_io_slider_stop_flag = false;
	static HANDLE diva_io_slider_thread = NULL;
	static HANDLE diva_io_led_thread;
	static bool diva_io_led_stop_flag;

	static HANDLE g_device_handle;
	static HANDLE g_lights_handle;
	struct RedBoardState g_controller_data;
	bool g_avail[4] = { false };
	UCHAR g_brg[101] = { 0 };
	UCHAR g_butled = 0;
	UCHAR g_compressed_buffer[128] = { 0 };

#define LZFX_ESIZE      -1      /* Output buffer too small */
#define LZFX_ECORRUPT   -2      /* Invalid data for decompression */
#define LZFX_EARGS      -3      /* Arguments invalid (NULL) */
#define LZFX_HLOG 16
#define LZFX_HSIZE (1 << (LZFX_HLOG))
#define fx_expect_false(expr)  (expr)
#define fx_expect_true(expr)   (expr)
	typedef unsigned char u8;
	typedef const u8* LZSTATE[LZFX_HSIZE];

	/* Define the hash function */
#define LZFX_FRST(p)     (((p[0]) << 8) | p[1])
#define LZFX_NEXT(v,p)   (((v) << 8) | p[2])
#define LZFX_IDX(h)      ((( h >> (3*8 - LZFX_HLOG)) - h  ) & (LZFX_HSIZE - 1))

/* These cannot be changed, as they are related to the compressed format. */
#define LZFX_MAX_LIT        (1 <<  5)
#define LZFX_MAX_OFF        (1 << 13)
#define LZFX_MAX_REF        ((1 << 8) + (1 << 3))

	static
		int lzfx_getsize(const void* ibuf, unsigned int ilen, unsigned int* olen);

	/* Compressed format

		There are two kinds of structures in LZF/LZFX: literal runs and back
		references. The length of a literal run is encoded as L - 1, as it must
		contain at least one byte.  Literals are encoded as follows:

		000LLLLL <L+1 bytes>

		Back references are encoded as follows.  The smallest possible encoded
		length value is 1, as otherwise the control byte would be recognized as
		a literal run.  Since at least three bytes must match for a back reference
		to be inserted, the length is encoded as L - 2 instead of L - 1.  The
		offset (distance to the desired data in the output buffer) is encoded as
		o - 1, as all offsets are at least 1.  The binary format is:

		LLLooooo oooooooo           for backrefs of real length < 9   (1 <= L < 7)
		111ooooo LLLLLLLL oooooooo  for backrefs of real length >= 9  (L > 7)
	*/
	int lzfx_compress(const void* const ibuf, const unsigned int ilen,
		void* obuf, unsigned int* const olen) {

		/* Hash table; an array of u8*'s which point
		   to various locations in the input buffer */
		const u8* htab[LZFX_HSIZE];

		const u8** hslot;       /* Pointer to entry in hash table */
		unsigned int hval;      /* Hash value generated by macros above */
		const u8* ref;          /* Pointer to candidate match location in input */

		const u8* ip = (const u8*)ibuf;
		const u8* const in_end = ip + ilen;

		u8* op = (u8*)obuf;
		const u8* const out_end = (olen == NULL ? NULL : op + *olen);

		int lit;    /* # of bytes in current literal run */

		unsigned long off;

		if (olen == NULL) return LZFX_EARGS;
		if (ibuf == NULL) {
			if (ilen != 0) return LZFX_EARGS;
			*olen = 0;
			return 0;
		}
		if (obuf == NULL) {
			if (olen != 0) return LZFX_EARGS;
			return lzfx_getsize(ibuf, ilen, olen);
		}

		memset((uint8_t*)htab, 0, sizeof(htab));

		/*  Start a literal run.  Whenever we do this the output pointer is
			advanced because the current byte will hold the encoded length. */
		lit = 0; op++;

		hval = LZFX_FRST(ip);

		while (ip + 2 < in_end) {   /* The NEXT macro reads 2 bytes ahead */

			hval = LZFX_NEXT(hval, ip);
			hslot = htab + LZFX_IDX(hval);

			ref = *hslot; *hslot = ip;

			if (ref < ip
				&& (off = ip - ref - 1) < LZFX_MAX_OFF
				&& ip + 4 < in_end  /* Backref takes up to 3 bytes, so don't bother */
				&& ref > (u8*)ibuf
				&& ref[0] == ip[0]
				&& ref[1] == ip[1]
				&& ref[2] == ip[2]) {

				unsigned int len = 3;   /* We already know 3 bytes match */
				const unsigned int maxlen = in_end - ip - 2 > LZFX_MAX_REF ?
					LZFX_MAX_REF : in_end - ip - 2;

				/* lit == 0:  op + 3 must be < out_end (because we undo the run)
				   lit != 0:  op + 3 + 1 must be < out_end */
				if (fx_expect_false(op - !lit + 3 + 1 >= out_end))
					return LZFX_ESIZE;

				op[-lit - 1] = lit - 1; /* Terminate literal run */
				op -= !lit;               /* Undo run if length is zero */

				/*  Start checking at the fourth byte */
				while (len < maxlen && ref[len] == ip[len])
					len++;

				len -= 2;  /* We encode the length as #octets - 2 */

				/* Format 1: [LLLooooo oooooooo] */
				if (len < 7) {
					*op++ = (off >> 8) + (len << 5);
					*op++ = off;

					/* Format 2: [111ooooo LLLLLLLL oooooooo] */
				}
				else {
					*op++ = (off >> 8) + (7 << 5);
					*op++ = len - 7;
					*op++ = off;
				}

				lit = 0; op++;

				ip += len + 1;  /* ip = initial ip + #octets -1 */

				if (fx_expect_false(ip + 3 >= in_end)) {
					ip++;   /* Code following expects exit at bottom of loop */
					break;
				}

				hval = LZFX_FRST(ip);
				hval = LZFX_NEXT(hval, ip);
				htab[LZFX_IDX(hval)] = ip;

				ip++;   /* ip = initial ip + #octets */

			}
			else {
				/* Keep copying literal bytes */

				if (fx_expect_false(op >= out_end)) return LZFX_ESIZE;

				lit++; *op++ = *ip++;

				if (fx_expect_false(lit == LZFX_MAX_LIT)) {
					op[-lit - 1] = lit - 1; /* stop run */
					lit = 0; op++; /* start run */
				}

			} /* if() found match in htab */

		} /* while(ip < ilen -2) */

		/*  At most 3 bytes remain in input.  We therefore need 4 bytes available
			in the output buffer to store them (3 data + ctrl byte).*/
		if (op + 3 > out_end) return LZFX_ESIZE;

		while (ip < in_end) {

			lit++; *op++ = *ip++;

			if (fx_expect_false(lit == LZFX_MAX_LIT)) {
				op[-lit - 1] = lit - 1;
				lit = 0; op++;
			}
		}

		op[-lit - 1] = lit - 1;
		op -= !lit;

		*olen = op - (u8*)obuf;
		return 0;
	}

	/* Decompressor */
	int lzfx_decompress(const void* ibuf, unsigned int ilen,
		void* obuf, unsigned int* olen) {

		u8 const* ip = (const u8*)ibuf;
		u8 const* const in_end = ip + ilen;
		u8* op = (u8*)obuf;
		u8 const* const out_end = (olen == NULL ? NULL : op + *olen);

		unsigned int remain_len = 0;
		int rc;

		if (olen == NULL) return LZFX_EARGS;
		if (ibuf == NULL) {
			if (ilen != 0) return LZFX_EARGS;
			*olen = 0;
			return 0;
		}
		if (obuf == NULL) {
			if (olen != 0) return LZFX_EARGS;
			return lzfx_getsize(ibuf, ilen, olen);
		}

		do {
			unsigned int ctrl = *ip++;

			/* Format 000LLLLL: a literal byte string follows, of length L+1 */
			if (ctrl < (1 << 5)) {

				ctrl++;

				if (fx_expect_false(op + ctrl > out_end)) {
					--ip;       /* Rewind to control byte */
					goto guess;
				}
				if (fx_expect_false(ip + ctrl > in_end)) return LZFX_ECORRUPT;

				do
					*op++ = *ip++;
				while (--ctrl);

				/*  Format #1 [LLLooooo oooooooo]: backref of length L+1+2
								  ^^^^^ ^^^^^^^^
									A      B
						   #2 [111ooooo LLLLLLLL oooooooo] backref of length L+7+2
								  ^^^^^          ^^^^^^^^
									A               B
					In both cases the location of the backref is computed from the
					remaining part of the data as follows:

						location = op - A*256 - B - 1
				*/
			}
			else {

				unsigned int len = (ctrl >> 5);
				u8* ref = op - ((ctrl & 0x1f) << 8) - 1;

				if (len == 7) len += *ip++;    /* i.e. format #2 */

				len += 2;    /* len is now #octets */

				if (fx_expect_false(op + len > out_end)) {
					ip -= (len >= 9) ? 2 : 1;   /* Rewind to control byte */
					goto guess;
				}
				if (fx_expect_false(ip >= in_end)) return LZFX_ECORRUPT;

				ref -= *ip++;

				if (fx_expect_false(ref < (u8*)obuf)) return LZFX_ECORRUPT;

				do
					*op++ = *ref++;
				while (--len);
			}

		} while (ip < in_end);

		*olen = op - (u8*)obuf;

		return 0;

	guess:
		rc = lzfx_getsize(ip, ilen - (ip - (u8*)ibuf), &remain_len);
		if (rc >= 0) *olen = remain_len + (op - (u8*)obuf);
		return rc;
	}

	/* Guess len. No parameters may be NULL; this is not checked. */
	static
		int lzfx_getsize(const void* ibuf, unsigned int ilen, unsigned int* olen) {

		u8 const* ip = (const u8*)ibuf;
		u8 const* const in_end = ip + ilen;
		int tot_len = 0;

		while (ip < in_end) {

			unsigned int ctrl = *ip++;

			if (ctrl < (1 << 5)) {

				ctrl++;

				if (ip + ctrl > in_end)
					return LZFX_ECORRUPT;

				tot_len += ctrl;
				ip += ctrl;

			}
			else {

				unsigned int len = (ctrl >> 5);

				if (len == 7) {     /* i.e. format #2 */
					len += *ip++;
				}

				len += 2;    /* len is now #octets */

				if (ip >= in_end) return LZFX_ECORRUPT;

				ip++; /* skip the ref byte */

				tot_len += len;

			}

		}

		*olen = tot_len;

		return 0;
	}

	int hid_get_report(HANDLE device_handle, uint8_t* buf, uint8_t report_id, uint8_t nb_bytes)
	{
		DWORD          bytesRead = 0;
		static uint8_t tmp_buf[128];

		if (buf == NULL) return -1;

		tmp_buf[0] = report_id;

		(void)ReadFile(device_handle, tmp_buf, nb_bytes * 2, &bytesRead, NULL);
		// bytesRead should either be nb_bytes*2 (if it successfully read 2 reports) or nb_bytes (only one)
		if (bytesRead != nb_bytes * 2 && bytesRead != nb_bytes)
		{
			printf("[TLAC] hid_get_report(): HID read error (expected %u (or twice that), but got %lu bytes)\n", nb_bytes, bytesRead);
			return -1;
		}
		//printf("[TLAC] hid_get_report(): Read report ok.\r\n");

		/* HID read ok, copy latest report bytes */
		memcpy(buf, tmp_buf + bytesRead - nb_bytes, nb_bytes);

		return 0;
	}

	int hid_set_report(HANDLE device_handle, const uint8_t* buf, uint8_t report_id, uint8_t nb_bytes)
	{
		DWORD   bytesWritten = 0;
		uint8_t tmp_buf[128] = { 0 };
		tmp_buf[0] = report_id;
		memcpy(tmp_buf + 1, buf, nb_bytes);
		/* send HID Report */
		WriteFile(device_handle, tmp_buf, 49, &bytesWritten, NULL); //TODO: retrieve 49 value from the device getcaps, nb_bytes+1 should work but makes chuniold crash somehow
		return 0; //best effort
	}

	int hid_set_report_raw(HANDLE device_handle, const uint8_t* buf, uint8_t report_id, uint8_t nb_bytes)
	{
		DWORD     bytesWritten = 0;
		if (buf[0] != report_id)
			return -1;
		/* send HID Report */
		WriteFile(device_handle, buf, nb_bytes, &bytesWritten, NULL); //TODO: retrieve 49 value from the device getcaps, nb_bytes+1 should work but makes chuniold crash somehow
		return 0; //best effort
	}

	int hid_set_feature_report_raw(HANDLE device_handle, const uint8_t* buf, uint8_t report_id, uint8_t nb_bytes)
	{
		DWORD     bytesWritten = 0;
		if (buf[0] != report_id)
			return -1;
		/* send HID Report */
		BOOL ret = HidD_SetFeature(device_handle, (uint8_t*)buf, nb_bytes);
		return 0; //best effort
	}

	static int controller_write_leds() {
		if (g_lights_handle == NULL)
			return -1;

		static uint8_t but_led[4]; /* button leds */

		//printf("buttons: %02x\n\n",g_butled);
		but_led[0] = g_butled & 0x01 ? 0xFF : 0x00; //Triangle
		but_led[1] = g_butled & 0x02 ? 0xFF : 0x00; //Square
		but_led[2] = g_butled & 0x04 ? 0xFF : 0x00; //Cross
		but_led[3] = g_butled & 0x08 ? 0xFF : 0x00; //Circle

		hid_set_report(g_lights_handle, but_led, REPORTID_LIGHT_OUTPUT_3, 4);

		/* slider lights */
		if (g_avail[3])
		{
			hid_set_feature_report_raw(g_lights_handle, g_compressed_buffer, REPORTID_LIGHT_COMPRESSED, 64);
			g_avail[3] = false;
		}
		else
		{
			/* fallback to partial updates */
			if (g_avail[0])
			{
				hid_set_report_raw(g_lights_handle, g_brg, REPORTID_LIGHT_OUTPUT_1, 49); //first 48 leds are on report 1
				g_avail[0] = false;
			}
			if (g_avail[1])
			{
				hid_set_report_raw(g_lights_handle, g_brg + 49, REPORTID_LIGHT_OUTPUT_2, 49); //last 48 on another one
				g_avail[1] = false;
			}
		}

		return 0;

	}

	unsigned int __stdcall diva_io_slider_thread_proc(void* ctx)
	{
		while (!diva_io_slider_stop_flag) {
			bool res = (hid_get_report(g_device_handle, (uint8_t*)g_controller_data.state, INPUT_REPORT_ID, sizeof(g_controller_data)) == 0);
			//printf("[TLAC] diva_io_slider_thread_proc(): Read report %d.\r\n", res);
		}

		return 0;
	}

	static unsigned int __stdcall diva_io_led_thread_proc(void* ctx)
	{
		while (!diva_io_led_stop_flag) {
			controller_write_leds();
		}

		return 0;
	}

	// GUID_DEVCLASS_HIDCLASS
	static GUID hidclass_guid = { 0x745a17a0, 0x74d3, 0x11d0, {0xb6, 0xfe, 0x00, 0xa0, 0xc9, 0x0f, 0x57, 0xda} };

	static BOOLEAN get_device_path(WCHAR* lPath, uint16_t vid, uint16_t pid, int8_t mi)
	{
		const GUID* guid = &hidclass_guid;
		HidD_GetHidGuid(&hidclass_guid);
		// Get device interface info set handle
		// for all devices attached to system
		HDEVINFO hDevInfo = SetupDiGetClassDevs(guid, NULL, NULL, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE); // Function class devices.
		if (hDevInfo == INVALID_HANDLE_VALUE)
			return FALSE;

		// Retrieve a context structure for a device interface of a device information set.
		BYTE                             buf[1024];
		PSP_DEVICE_INTERFACE_DETAIL_DATA pspdidd = (PSP_DEVICE_INTERFACE_DETAIL_DATA)buf;
		SP_DEVICE_INTERFACE_DATA         spdid;
		SP_DEVINFO_DATA                  spdd;
		DWORD                            dwSize;
		WCHAR vidstr[64] = { 0 };
		WCHAR mistr[64] = { 0 };

		(void)pid; /* not used for now */
		swprintf(vidstr, 64, L"vid_%04x&", vid);
		if (mi != -1) swprintf(mistr, 64, L"&mi_%02x", mi);

		spdid.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

		// Iterate through all the interfaces and try to match one based on
		// the device number.    
		for (DWORD i = 0; SetupDiEnumDeviceInterfaces(hDevInfo, NULL, guid, i, &spdid); i++)
		{
			// Get the device path.
			dwSize = 0;
			SetupDiGetDeviceInterfaceDetail(hDevInfo, &spdid, NULL, 0, &dwSize, NULL);
			if (dwSize == 0 || dwSize > sizeof(buf))
				continue;

			pspdidd->cbSize = sizeof(*pspdidd);
			ZeroMemory((PVOID)&spdd, sizeof(spdd));
			spdd.cbSize = sizeof(spdd);
			if (!SetupDiGetDeviceInterfaceDetail(hDevInfo, &spdid, pspdidd,
				dwSize, &dwSize, &spdd))
				continue;

			/* check if the device contains our wanted vid/pid */
			//printf("checking path %ls... ", pspdidd->DevicePath);
	 //       if ( strstr( pspdidd->DevicePath, vidpidstr ) == NULL )
			if (wcsstr(pspdidd->DevicePath, vidstr) == NULL || ((mi != -1) && wcsstr(pspdidd->DevicePath, mistr) == NULL))
			{
				//printf("that's not it.\r\n");
				continue;
			}
			//printf("\r\nDevice found at %ls\r\n", pspdidd->DevicePath);
			//copy devpath into lPath
			wcscpy_s(lPath, 128, pspdidd->DevicePath);
			SetupDiDestroyDeviceInfoList(hDevInfo);
			return TRUE;
		}
		SetupDiDestroyDeviceInfoList(hDevInfo);
		return FALSE;
	}

	/**
	 * Initialize the g_hid_handle global variable
	 * It will attempt to read paths from devicepath.dat file if it exists until it finds one which works.
	 * If nothing is found, as a last resort it will try the two default paths from the Due and Leonardo
	 * versions of the firmware.
	 *
	 * @return 0 on success, -1 on error
	 */
	static int hid_open_device(HANDLE* device_handle, uint16_t vid, uint16_t pid, uint8_t mi) {
		static uint8_t err_count = 0;
		WCHAR path[256];

		if (!get_device_path(path, vid, pid, mi))
		{
			err_count++;
			if (err_count > 2) {
				printf("[TLAC] RedBoard::hid_open_device(): Could not init device after multiple attempts. Exiting.\r\n");
				exit(1);
			}
			return -1;
		}
		printf("[TLAC] RedBoard::hid_open_device(): Device detected in path %ls.\r\n", path);

		*device_handle = CreateFile(path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

		if (*device_handle == INVALID_HANDLE_VALUE)
		{
			printf("[TLAC] RedBoard::hid_open_device(): Could not open detected device (err = %lx).\r\n", GetLastError());
			return -1;
		}
		return 0;
	}

	/* OOP BEGIN */
	RedBoard *RedBoard::instance;

	RedBoard::RedBoard()
	{
	}

	RedBoard::~RedBoard()
	{
		if (diva_io_slider_thread != NULL) {
			diva_io_slider_stop_flag = true;
			WaitForSingleObject(diva_io_slider_thread, INFINITE);
			CloseHandle(diva_io_slider_thread);
			diva_io_slider_thread = NULL;
			diva_io_slider_stop_flag = false;
		}
		CloseHandle(g_device_handle);

		if (diva_io_led_thread != NULL) {
			diva_io_led_stop_flag = true;
			WaitForSingleObject(diva_io_led_thread, INFINITE);
			CloseHandle(diva_io_led_thread);
			diva_io_led_thread = NULL;
			diva_io_led_stop_flag = false;
		}
		if (g_lights_handle != NULL) CloseHandle(g_lights_handle);
	}

	bool RedBoard::TryInitializeInstance()
	{
		if (InstanceInitialized())
			return true;

		RedBoard *redboard = new RedBoard();

		BOOL success = redboard->Initialize();
		instance = success ? redboard : nullptr;

		if (!success)
			delete redboard;

		return success;
	}

	bool RedBoard::Initialize()
	{
		/* open slider controller interface (no interface for Hori official, interface 0 for RedBoard) */
		if (hid_open_device(&g_device_handle, 0x0f0d, 0x00fb, 0) != 0
			&& hid_open_device(&g_device_handle, 0x0f0d, 0x00fb, -1) != 0) /* hori official controller has only one interface */
		{
			printf("[TLAC] RedBoard::Initialize(): USB Device not found\n");
			return false;
		}

		/* try to open the HID lights interface (will fail for Hori official, no biggie) */
		if (hid_open_device(&g_lights_handle, 0x0f0d, 0x00fb, 1) != 0)
		{
			g_lights_handle = NULL;
		}

		g_brg[0] = REPORTID_LIGHT_OUTPUT_1;
		g_brg[49] = REPORTID_LIGHT_OUTPUT_2;
		g_compressed_buffer[0] = REPORTID_LIGHT_COMPRESSED;

		int hidres = HidD_SetNumInputBuffers(g_device_handle, 2);
		if (!hidres)
		{
			printf("[TLAC] RedBoard::Initialize(): ERROR SETNUMINPUTBUFFERS\n");
			printf("[TLAC] RedBoard::Initialize(): Error %lu setnuminputbuff\r\n", GetLastError());
			return false;
		}
		//printf("[TLAC] RedBoard::Initialize(): Found device, launch polling thread..\r\n");
		if (diva_io_slider_thread == NULL) {
			diva_io_slider_thread = (HANDLE)_beginthreadex(
				NULL,
				0,
				diva_io_slider_thread_proc,
				NULL,
				0,
				NULL);
		}

		if (g_lights_handle == NULL)
		{
			printf("[TLAC] RedBoard::Initialize(): In Hori pad mode: No HID lights\n");
			goto end; //hori pad doesn't have hid leds
		}

		if (diva_io_led_thread == NULL) {
			diva_io_led_thread = (HANDLE)_beginthreadex(
				NULL,
				0,
				diva_io_led_thread_proc,
				NULL,
				0,
				NULL);
		}
end:
		printf("[TLAC] RedBoard::Initialize(): Init Ok\n");
		return true;
	}

	bool RedBoard::PollInput()
	{
		lastState = currentState;
		currentState = g_controller_data;
		//memset(currentState.state, 0, sizeof(currentState.state));

		SetLED();
		return true;
	}

	bool RedBoard::SetLED()
	{
		if (g_lights_handle == NULL)
			return true;

		/* do not actually send leds as it will cause diva/pdloader to reset and reinit slider...
		 * here we're just preparing data, and anothre thread will send it.
		 */
		g_butled = *buttonLed;

		if (*sliderLedInit && !sliderLedData)
		{
			sliderLedData = reinterpret_cast<UCHAR *>(*(uint64_t *)(0x14cc5de40 + 0x68) + 0x189d);
		}
		if (sliderLedData)
		{
			if (g_avail[3])
			{
				/* compressed transfer pending */
				return true;
			}

			unsigned int size = 63;
			int ret = lzfx_compress(sliderLedData, 96, g_compressed_buffer + 2, &size);
			if (ret == 0)
			{
				//printf("DEBUG: using compression\r\n");
				g_compressed_buffer[1] = size;
				/* signal compressed transfer */
				g_avail[3] = true;
				return true;
			}

			//printf("DEBUG: NOT using compression (too large)\r\n");
			//VERBOSE_DEBUG("transfer too large for compressed update\n");
			/* Fallback to partial updates when not compressible enough */
			/* hid lights are in reverse order in redboard */
			static uint8_t rev_bits[96];

			for (uint8_t i = 0; i < 32; i++)
			{
				rev_bits[3 * i] = sliderLedData[3 * (31 - i)];
				rev_bits[3 * i + 1] = sliderLedData[3 * (31 - i) + 1];
				rev_bits[3 * i + 2] = sliderLedData[3 * (31 - i) + 2];
			}
			if (!g_avail[0] && memcmp(g_brg + 1, rev_bits, 48) != 0)
			{
				memcpy(g_brg + 1, rev_bits, 48);
				g_avail[0] = true;
			}
			if (!g_avail[1] && memcmp(g_brg + 50, rev_bits + 48, 48) != 0)
			{
				memcpy(g_brg + 50, rev_bits + 48, 48);
				g_avail[1] = true;
			}
		}
		return true;
	}

	bool RedBoard::IsDown(RedBoardButton button)
	{
		switch (button)
		{
		case RedBoardButton::RB_COIN:
			return false;
		case RedBoardButton::RB_SRV:
			return currentState.split.buttons & SERVICE;
		case RedBoardButton::RB_TEST:
			return currentState.split.buttons & TEST;
		case RedBoardButton::RB_START:
			return currentState.split.buttons & START;
		case RedBoardButton::RB_TRIANGLE:
			return currentState.split.buttons & TRIANGLE;
		case RedBoardButton::RB_SQUARE:
			return currentState.split.buttons & SQUARE;
		case RedBoardButton::RB_CROSS:
			return currentState.split.buttons & CROSS;
		case RedBoardButton::RB_CIRCLE:
			return currentState.split.buttons & CIRCLE;
		}
		return false;
	}

	bool RedBoard::IsUp(RedBoardButton button)
	{
		return !IsDown(button);
	}

	bool RedBoard::IsTapped(RedBoardButton button)
	{
		return IsDown(button) && WasUp(button);
	}

	bool RedBoard::IsReleased(RedBoardButton button)
	{
		return IsUp(button) && WasDown(button);
	}

	bool RedBoard::WasDown(RedBoardButton button)
	{
		switch (button)
		{
		case RedBoardButton::RB_COIN:
			return false;
		case RedBoardButton::RB_SRV:
			return lastState.split.buttons & SERVICE;
		case RedBoardButton::RB_TEST:
			return lastState.split.buttons & TEST;
		case RedBoardButton::RB_START:
			return lastState.split.buttons & START;
		case RedBoardButton::RB_TRIANGLE:
			return lastState.split.buttons & TRIANGLE;
		case RedBoardButton::RB_SQUARE:
			return lastState.split.buttons & SQUARE;
		case RedBoardButton::RB_CROSS:
			return lastState.split.buttons & CROSS;
		case RedBoardButton::RB_CIRCLE:
			return lastState.split.buttons & CIRCLE;
		}
		return false;
	}

	bool RedBoard::WasUp(RedBoardButton button)
	{
		return !WasDown(button);
	}

	uint32_t RedBoard::GetSlider()
	{
		return currentState.split.axis ^ ((uint32_t)0x80808080);
	};
}
